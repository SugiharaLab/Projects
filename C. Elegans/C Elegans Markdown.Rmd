---
title: "C. Elegans"
author: "Erik Saberski"
date: "6/7/2020"
output:
  html_document: default
  word_document: default
  pdf_document: default
---

Here, we go over the analysis of Networks of Causal Linkage Between Eigenmodes Characterize Behavioral Dynamics of Caenorhabditis elegans.

First, we calculate CCM values for the 12 foraging worms (Broekmans et al. 2016) across a range of time lags (tp).

Because the the timeseries are quite extensive (33,600 values), we take many randomsamples of the entire timeseries to make computation faster. Further, for consistency we use one embedding dimension for all calculations (E=10), but later calculate the optimal embedding dimension for each pair of eigenmodes.

First we create some functions we will use in our analysis.

```{r}
library(rEDM)
library(parallel)

#This is the function we will be using to normalize values between 0 and 1.
normalize <- function(data){
  ts = data[!is.na(data)]
  if(length(ts)!= 0){
  data = (data - min(ts))/(max(ts)-min(ts))
  }
  return(data)
}

#This function make an embedding with E lags of a library timeseries, with corresponding target time series lagged by tp.
make_worm_block <- function(target, lib, E = 3, tp = 0){
    matrix  =array(0, dim = c(length(target)-E,E+1))
    for(e in c(0:(E-1))){
      matrix[,e+1] <- lib[(1+e):(length(lib) - E + e )]
    }
    if(tp != 0){
      matrix = matrix[-c(1:-tp),]
    }
    matrix[,E+1] <- target[E:(nrow(matrix)+E-1)]
    
    rs = rowSums(matrix)
    nas = which(is.na(rs))
    count = 0
    if(length(nas) >0){
      matrix = matrix[-nas,]
    }
    return(matrix)
}

#This function calls make_worm_block() and uses the created block to run CCM between 1 target eigenworm and the 4 others across a range of values for tp. The number of samples indicates the size of the library, where that many time points are randomly chosen from the entire time series. Trials indicates the number of times this random selection is repeated.

do_worm_ccm_TP <- function(target, tps = c(-32:0), samples = 200, trials = 50, E = 10){
  rhos_total = array(NA, dim= c(length(tps),4))
  for(l in c(1:4)){
    lib = eigens[,l]
    rhos_tp = {}
    for(tp in tps){
      m<- make_worm_block(target,lib, E = E, tp = tp)
      rhos_avg = {}
      if(!is.null(nrow(m))){
        if(nrow(m) > samples){
          for(trial in c(1:trials)){
            
            m2 = m[sample(1:nrow(m), samples),]
            out <-  block_lnlp(m2, target_column = ncol(m), columns = c(1:(ncol(m)-1)), tp = 0, method = "simplex", silent = T)
            rhos_avg = c(rhos_avg,(out$rho))
          }
        }
      }
      rhos_tp = c(rhos_tp, mean(rhos_avg))
    }
    rhos_total[,l] <- rhos_tp
  }
  return(rhos_total)
}
do_worm_ccm_E <- function(E, target,lib, tp = 0, trials = 10,samples=250){
    rhos_avg = {}
    m<- make_worm_block2(target,lib, E = E, tp = tp)
    if(!is.null(nrow(m))){
      if(nrow(m) > samples){
        for(trial in c(1:trials)){
          
          
          m2 = m[sample(1:nrow(m), samples),]
          out <-  block_lnlp(m2, target_column = ncol(m), columns = c(1:(ncol(m)-1)), tp = 0,
                             method = "simplex", silent = T)
          rhos_avg = c(rhos_avg,(out$rho))
        }
      }
    }
    return(mean(rhos_avg))
  }
```

Here, we loop through all worms, preforming those funcitons.

```{r, eval = F}
#We store all output in the "totals_foraging" array. This contains all 33 CCM values (tp = -32:0) for each pair of eigenworms for all 12 individuals. 

#This will loop through and read the .txt file for each of the timeseries of the 12 foraging worms
totals_foraging = array(NA, dim = c(33,4,4,12))
  tps = c(-32:0)
  for(n in c(1:12)){
    eigens=  read.csv(paste("Foraging/w",n,"/tracking.txt",
                            sep = ""), header = F, sep = "")
    out = mclapply(as.data.frame(eigens), do_worm_ccm_TP, mc.cores = detectCores()-1)
    out = as.data.frame(out)
    loop = 1
    for(i in c(1:4)){
      for(j in c(1:4)){
        totals_foraging[,i,j,n] <- out[,loop]
        loop = loop+1
      }
    }
  }

```


Now that we have all the CCM values, we plot them against TP for each pair.

Note that the sampling frequency is 16 Hz, so checking lags up to 32 values is equivelant to lags up to 2 seconds.

```{r}
  load("CCM_profile_foraging.RData")
  par(mfrow = c(4,4), mai = c(.3,.3,.3,.3))
  breaks = seq(0,42,6)
  for(i in c(1:4)){
    for(j in c(1:4)){
      if(i != j){
        plot(0,0, xlim =c(-2,0), ylim = c(0,1), col = "white")
        t1 = {}
        for(p in c(1:ncol(totals_foraging[,i,j,]))){
          lne = normalize(totals_foraging[,i,j,p])
          t1 = rbind(t1, lne)
          lines(c(-32:0)/16, lne, col = rgb(.2,.2,.2,.15))
        }
        avg1 = normalize(colMeans(t1, na.rm = T))
        lines(c(-32:0)/16,avg1, lwd = 3, col = 'red')
      }else{
        plot.new()
      }
    }
  }

```

Now, to find the optimal embedding dimension (E), we take the peak value of the plots above and check all embedding dimensions from 2 to 40 to see which one most obtains the highest CCM value (CCM rho).

```{r, eval = F}
#We store all output in the "totals_foraging" array. This contains all 33 CCM values (tp = -32:0) for each pair of eigenworms for all 12 individuals. 

#This will loop through and read the .txt file for each of the timeseries of the 12 foraging worms
totals_E = array(NA, dim = c(4,4,12))
Es = c(2:40)
for(n in c(1:12)){
  print(n)
  eigens=  read.csv(paste("Foraging/w",n,"/tracking.txt",
                          sep = ""), header = F, sep = "")
  for(i in c(1:4)){
    print(i)
    for(j in c(1:4)){
      t1 = {}
      for(p in c(1:ncol(totals_foraging[,i,j,]))){
        lne = normalize(totals_foraging[,i,j,p])
        t1 = rbind(t1, lne)
      }
      avg1 = normalize(colMeans(t1, na.rm = T))
      tp = c(-32:0)[which.max(avg1)]
      if(i != j){
        out <- mclapply(Es,do_worm_ccm_E,  target =eigens[,i],
                      lib = eigens[,j],mc.cores = detectCores()-1, trials = 10, samples = 100)
        out = t(as.data.frame(out))
        totals_E[i,j,n] <- Es[which.max(out)]
      }
    }
  }
  
  
}
```
Now we plot the optimal embedding dimension for each target (driving) eigenworm. 

```{r}
load("foraging_Es.RData")
par(mfrow=c(1,4))
breaks = seq(0,42,3)
for(i in c(1:4)){
  hist(totals_E[i,,], breaks = breaks, col = rgb(.7,.2,.2,.5), main = "", xlab = "Embedding Dimension")
}
```

Now we repeate this process for the escape response worms (Broekmans et al. 2016). 

Note that here we check a tp range from (-40:0) because this data was sampled at a frequency of 20 Hz, so in order to match the 2 second lag tested above, we need to test tp range up to 40.

```{r, eval  =F}
{
  do_ccm_escaping <- function(tp,m,E = 5){
    out <- ccm(m, target_column = 1, lib_column = 2, lib_sizes = 100, random_libs = T, E = E,
               num_samples = 50, tp = tp, silent = T, exclusion_radius = 10)
    return(mean(out$rho))
  }
  nums = c(0:97)
  exc = c(6,13, 17, 30, 42, 88) #These are excluded due to lack of movement (Broekmans et al. 2016)
  nums = nums[-which(nums %in% exc)]
  
  totals_Escaping = array(NA, dim = c(41,4,4,length(nums)))
  count = 1
  for(n1 in c(1:length(nums))){
    print(n1)
    n = nums[n1]
    found = F
    
    
    if(n >= 10){
      files = list.files(paste("EscapeResponse/0",n,
                               
                               sep = ""))
      for(f in files){
        if(grepl( "tracking.txt", f,fixed = TRUE)){
          
          found = T
        }}
      if(found == T){
        eigens=  read.csv(paste("EscapeResponse/0",n,
                                "/tracking.txt",
                                sep = ""),
                          header = F, sep = "")
      }
    }
    
    if(n < 10){
      files = list.files(paste("EscapeResponse/00",n,
                               
                               sep = ""))
      for(f in files){
        if(grepl( "tracking.txt", f,fixed = TRUE)){
          
          found = T
        }}
      if(found == T){
        eigens=  read.csv(paste("EscapeResponse/00",n,
                                "/tracking.txt",
                                sep = ""),
                          header = F, sep = "")
      }
    }
    if(found == T){
      eigens = eigens[200:600,] #the first 200 timepoints are pre-stimulus and are thus excluded.
      for(i in c(1:4)){
        print(i)
        for(j in c(1:4)){
          if(i != j){
            m = cbind(eigens[,i], eigens[,j])
            tps = mclapply(c(-40:0), do_ccm_escaping, m=m, mc.cores = 7)
            tps = t(as.data.frame(tps))
            totals_Escaping[,i,j,count] <- tps
          }
        }
      }
      
      count = count+1
    }
    
  }
} 

```

Plotting these gives us:

```{r, warning=F}
load("CCM_profile_escaping.RData")
  par(mfrow = c(4,4), mai = c(.3,.3,.3,.3))
  for(i in c(1:4)){
    for(j in c(1:4)){
      if(i != j){
        plot(0,0, xlim =c(-2,0), ylim = c(0,1), col = "white")
        t1 = {}
        for(p in c(1:ncol(totals_escaping[,i,j,]))){
          lne = normalize(totals_escaping[,i,j,p])
          t1 = rbind(t1, lne)
          lines(c(-40:0)/20, lne, col = rgb(.2,.2,.2,.15))
        }
        avg1 = normalize(colMeans(t1, na.rm = T))
        lines(c(-40:0)/20,avg1, lwd = 3, col = 'blue')
      }else{
        plot.new()
      }
    }
  }

```

Similarly, getting the optimal E for these:

```{r, eval = F}

  do_ccm_escaping <- function(E,m,tp){
    out <- ccm(m, target_column = 1, lib_column = 2, lib_sizes = 50, random_libs = T, E = E,
               num_samples = 50, tp = tp, silent = T, exclusion_radius = 10)
    return(mean(out$rho))
  }
  nums = c(0:97)
  exc = c(6,13, 17, 30, 42, 88)
  nums = nums[-which(nums %in% exc)]
  
  totals_E_escaping = array(NA, dim = c(4,4,length(nums)))
  count = 1
  load("CCM_profile_escaping.RData")
  for(n1 in c(1:length(nums))){
    n = nums[n1]
    found = F
    
    {
    if(n >= 10){
      files = list.files(paste("EscapeResponse/0",n,
                               
                               sep = ""))
      for(f in files){
        if(grepl( "tracking.txt", f,fixed = TRUE)){
          
          found = T
        }}
      if(found == T){
        eigens=  read.csv(paste("EscapeResponse/0",n,
                                "/tracking.txt",
                                sep = ""),
                          header = F, sep = "")
      }
    }
    
    if(n < 10){
      files = list.files(paste("EscapeResponse/00",n,
                               
                               sep = ""))
      for(f in files){
        if(grepl( "tracking.txt", f,fixed = TRUE)){
          
          found = T
        }}
      if(found == T){
        eigens=  read.csv(paste("EscapeResponse/00",n,
                                "/tracking.txt",
                                sep = ""),
                          header = F, sep = "")
      }
    }
    }
    
    Es = c(2:40)
    if(found == T){
      eigens = eigens[200:600,] #the first 200 timepoints are pre-stimulus and are thus excluded.
      for(i in c(1:4)){
        for(j in c(1:4)){
          if(i != j){
            m = cbind(eigens[,i], eigens[,j])
            t1 = {}
            for(p in c(1:91)){
              lne = normalize(totals[,i,j,p])
              t1 = rbind(t1, lne)
            }
            avg1 = normalize(colMeans(t1, na.rm = T))
            tp = c(-40:0)[which.max(avg1)]
           
            out <- mclapply(Es, do_ccm_escaping, m=m, tp=tp, mc.cores = 7)
            out = t(as.data.frame(out))
            
            totals_E_escaping[i,j,count] <- Es[which.max(out)]
            
            # print(best_E)
          }
          
        }
      }
      
      count = count+1
    }
    
  }




```

```{r}
load("escaping_Es.RData")
par(mfrow = c(1,4))
breaks = seq(0,42,3)
  for(i in c(1:4)){
    h1 = hist(totals_E[i,,], breaks = breaks, plot = T, col = rgb(.2,.2,.8,.6),
              main= "", xlab = "Embedding Dimension")
  }

```

Now that we have done all of the CCM analyses for foraging and escaping worms, we can compare the difference between them.

Here we first do difference between all pairs of foraging worms:

```{r}
#Difference between pairs of foraging worms:
{
  load("CCM_profile_foraging.RData")
  totals = totals_foraging
  ds_f = {}
  for(i in c(1:12)){
    for(j in c(1:12)){
      if(i!= j){
        ds = {}
        for(x in c(1:4)){
          for(y in c(1:4)){
            if(x!= y){
              a=totals[,x,y,i]
              b=totals[,x,y,j]
             
              a2 = normalize(a)
              b2 = normalize(b)
           
              a2 = a2[which(a>0 & b>0)]
              b2 = b2[which(a>0 & b>0)]
      
              d = mean(abs(a2 - b2), na.rm = T)
              ds = c(ds,d)
              
            }
          }
        }
        ds_f = c(ds_f, mean(ds,na.rm=T))
      }
    }
  }
  
} 
```

Next we do difference between pairs of escaping worms:

```{r}
{    
  load("CCM_profile_escaping.RData")

  ds_esc = {}
  for(i in c(1:91)){
    for(j in c(1:91)){
      if(i!= j){
        ds = {}
        for(x in c(1:4)){
          for(y in c(1:4)){
            if(x!= y){
              a=totals_escaping[,x,y,i]
              b=totals_escaping[,x,y,j]
          
              a2 = normalize(a)
              b2 = normalize(b)
             
              a2 = a2[which(a>0 & b>0)]
              b2 = b2[which(a>0 & b>0)]
            
              d = mean(abs(a2 - b2), na.rm = T)
              ds = c(ds,d)
              
            }
          }
        }
        ds_esc = c(ds_esc, mean(ds))
      }
    }
  }
  
} 
```

Lastly, we compare distances between pairs of foraging worms and escaping worms. Because they are smapled at different frequencies, we interpolate data to get them both to have a value at every 0.1 seconds from -2 to 0 seconds.

```{r}

interpolate <- function(vals, times, out_f = .1){
  fit = {}
  desired = seq(-2, 0, out_f)
  for(d in desired){
    df = times-d
    df[is.na(df)] = -100 
    found = F 
    i = 2
    while(found == F){
      if(df[(i-1)] <= 0 & df[i] >= 0){
        found = T
      }
      
      i = i+1
      if(i>500){print(i)}
    }
    i = i-1
    v1 = vals[i]
    v2 = vals[i-1]
    
    slope = (v2-v1)/(times[i] - times[i-1])
    
    v = vals[i-1] + df[i-1]*slope
    fit = c(fit, v)
  }
  return(fit)
}

totals_f = totals_foraging
totals_e = totals_escaping

times_f = seq(-2,0,1/16)
times_e = seq(-2,0, 1/20)
d_total = {}
for(i in c(1:12)){
  for(j in c(1:91)){
    ds = {}
    for(x in c(1:4)){
      for(y in c(1:4)){
        if(x!= y){
        a = totals_f[,x,y,i]
        b = totals_e[,x,y,j]
        
        a = interpolate(a, times_f, .1)
        b = interpolate(b, times_e, .1)
        a = normalize(a)
        b = normalize(b)
        
        a2 = a[which(a>0 & b>0)]
        b2 = b[which(a>0 & b>0)]
        
        d = mean(abs(a2-b2))
        ds = c(ds,d)
        
        }
        
      }
      
    }
    d_total = c(d_total, mean(ds))
  }
}

boxplot( ds_f,ds_esc, d_total )

```

Now we repeate the analysis of foraging vs escape difference, except we randomly shuffle the timeseries. This will create out baseline for what "random differences" would be; or rather, no similar dynamics.

```{r}


interpolate <- function(vals, times, out_f = .1){
  fit = {}
  desired = seq(-2, 0, out_f)
  for(d in desired){
    df = times-d
    df[is.na(df)] = -100 
    found = F 
    i = 2
    while(found == F){
      if(df[(i-1)] <= 0 & df[i] >= 0){
        found = T
      }
      
      i = i+1
      if(i>500){print(i)}
    }
    i = i-1
    v1 = vals[i]
    v2 = vals[i-1]
    
    slope = (v2-v1)/(times[i] - times[i-1])
    
    v = vals[i-1] + df[i-1]*slope
    fit = c(fit, v)
  }
  return(fit)
}

totals_f = totals_foraging
totals_e = totals_escaping

times_f = seq(-2,0,1/16)
times_e = seq(-2,0, 1/20)
d_random = {}
for(i in c(1:12)){
  for(j in c(1:91)){
    ds = {}
    for(x in c(1:4)){
      for(y in c(1:4)){
        if(x!= y){
        a = totals_f[,x,y,i]
        b = totals_e[,x,y,j]
       
        a = interpolate(a, times_f, .1)
        b = interpolate(b, times_e, .1)
        a = normalize(a)
        b = normalize(b)
        
        a2 = a[which(a>0 & b>0)]
        b2 = b[which(a>0 & b>0)]
        
        d = mean(abs(sample(a2)-sample(b2)))
        ds = c(ds,d)
        
        }
        
      }
      
    }
    d_random = c(d_random, mean(ds))
  }
}


boxplot( ds_f,ds_esc, d_total, d_random)
```


Now we compare differences between different genotypes.

To generate the CCM profiles of each worm, raw timeseries data from http://openworm.org/ was used in conjunction with the functions above.  

First, we average the CCM profiles of individuals with the same genotype.
```{r}
genes_found = list.files("strains_CCM_profile")
for(g in genes_found){
  count = count + 1
  load(paste("strains_CCM_profile/",g,"_CCM_profile.RData" ,sep = ""))
  for(i in c(1:4)){
    for(j in c(1:4)){
      if(i != j){
        t1 = {}
        for(p in c(1:ncol(totals[,i,j,]))){
          curr = totals[,i,j,p]
          curr[curr<0] = 0
          t1 = rbind(t1, normalize(curr))
        }
        avg = colMeans(t1, na.rm = T)
         # plot(avg)
        if(length(avg) == 11){
          all_genes[count,i,j,] <- normalize(avg)
        }
      }
    }
  }
}

```

Next we calculate the difference between all strains' CCM profiles.

```{r}
distances = array(NA, dim =c(length(genes_found),length(genes_found)) )
for(i in c(1:length(genes_found))){
  for(j in c(1:length(genes_found))){
    d = {}
    for(l1 in c(1:4)){
      for(l2 in c(1:4)){
        a = all_genes[i,l1,l2,]
        b = all_genes[j,l1,l2,]
        a2 = a[which(a>0 & b>0)]
        b2 = b[which(a>0 & b>0)]
        d = c(d, abs(a2-b2))
      }
    }
    distances[i,j] <- mean(d, na.rm = T)
    
  }
}

```

Now we have a distance matrix between all strains, we sort them into groups defined by Brown et al. (2013) and see how those groups of distances compare to the rest of the matrix.

```{r}
phenos = read.csv("Categories_Brown_2013.csv") #load in the data file from Brown et al. (2013)
ups = unique(phenos$Phenotypic.or.Functional.Class)

outs <- as.data.frame(array(NA, dim = c(9,1)))
count = 0
medians = {}
for(u in ups){
  count = count+1
  is = which(phenos$Phenotypic.or.Functional.Class == u)
  strains = phenos[is,]
  strains = as.character(strains$Strain)
  is2 = {}
  for(s in strains){
    if(s %in% genes_found){
      i = which(genes_found == s)
      is2 =c(is2,i)
    }
  }
  mini = as.vector(distances[is2,is2])
  mini = mini[mini>0]
  medians = c(medians, median(mini,na.rm=T))
  outs$V1[count] <- list(mini)
}
outs$V1 = outs$V1[order(medians)] #order them by increasing median

#Separate them out into individual variables and compare boxplots
a1 = outs$V1[[1]]
a2 = outs$V1[[2]]
a3 = outs$V1[[3]]
a4 = outs$V1[[4]]
a5 = outs$V1[[5]]
a6 = outs$V1[[6]]
a7 = outs$V1[[7]]
a8 = outs$V1[[8]]
a9 = outs$V1[[9]]
boxplot(a1,a2,a3,a4,a5,a6,a7,a8,a9, ylim = c(0.15,0.3), 
        names = ups[order(medians)], las = 2)


```


Lastly, we look at the egl strains that are thought to have effects on HSNs and those that do not

```{r}
test = read.csv("HSN_mutations.csv", header = T)
g1 = as.character(test[,1])[1:18]
g2 = as.character(test[,2])

is = {}
for(g in g1){
  i = which(genes_found == g)
  is = c(is,i)
}
is2 = {}
for(g in g2){
  i = which(genes_found == g)
  is2 = c(is2,i)
}

b1 = as.vector(distances[is,is])
b2 = as.vector(distances[is2,is2])
boxplot(b1,b2, ylim = c(0.17,0.4), names = c("HSN Effected", "HSN Not Effected"))
stat = t.test(b1,b2)
text(1.5,.387,paste("p =", formatC(stat$p.value, format = "f", digits = 4)))


```